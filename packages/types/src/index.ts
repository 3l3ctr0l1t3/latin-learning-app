/**
 * TYPESCRIPT TYPES FOR LATIN LEARNING APPLICATION
 * 
 * TypeScript is JavaScript with type definitions - similar to Java's type system.
 * This file defines the "shape" of our data throughout the application.
 * Think of these as Java interfaces or classes that define data structures.
 * 
 * Why use TypeScript?
 * - Catches errors at compile time (like Java)
 * - Better IDE support with autocomplete
 * - Makes code self-documenting
 * - Easier refactoring
 */

/**
 * LatinWord Interface - Matches the structure from vocabulary.json
 * 
 * An "interface" in TypeScript is like a Java interface - it defines the structure
 * of an object but doesn't implement it. Every Latin word in our app will have
 * these properties.
 * 
 * The "export" keyword makes this available to other files (like Java's public)
 */
export interface LatinWord {
  // The nominative case - the basic form of the noun (e.g., "rosa" = rose)
  nominative: string;
  
  // The genitive case - shows possession, used to identify declension (e.g., "rosae")
  genitive: string;
  
  // Gender of the noun - important for Latin grammar
  // Using union type to match vocabulary.json values
  gender: 'masculine' | 'feminine' | 'neuter';
  
  // Declension tells us which pattern the noun follows when it changes form
  // Currently a number in the JSON (1, 2, 3, 4, 5) but we'll normalize to strings
  declension: 1 | 2 | 3 | 4 | 5 | '1st' | '2nd' | '3rd' | '4th' | '5th';
  
  // The primary Spanish translation of the word
  spanishMeaning: string;
  
  // Additional meanings or contexts for the word
  // Array of strings for multiple meanings
  additionalMeanings: string[];
  
  // We'll add these fields for our app's functionality
  id?: string;  // Optional unique identifier (generated by our app)
  exampleSentence?: string;  // Optional AI-generated example
}

/**
 * NormalizedLatinWord Interface
 * 
 * This is the version we'll use after normalizing the data from vocabulary.json
 * It has consistent types and additional fields we need
 */
export interface NormalizedLatinWord {
  // Unique identifier for each word (we'll generate this)
  id: string;
  
  // The nominative case
  nominative: string;
  
  // The genitive case
  genitive: string;
  
  // Declension as a string (normalized from number)
  declension: '1st' | '2nd' | '3rd' | '4th' | '5th';
  
  // Gender (already correct in JSON)
  gender: 'masculine' | 'feminine' | 'neuter';
  
  // Primary Spanish translation
  spanishTranslation: string;
  
  // Additional meanings
  additionalMeanings: string[];
  
  // Optional AI-generated example sentence
  exampleSentence?: string;
}

/**
 * StudySession Interface
 * 
 * Represents a complete study session from start to finish.
 * This tracks what the user is studying and their progress.
 */
export interface StudySession {
  // Unique session identifier
  id: string;
  
  // Array of NormalizedLatinWord objects - the words selected for this session
  // In React, we often work with arrays of objects like this
  words: NormalizedLatinWord[];
  
  // Duration in minutes - using union type to restrict to specific values
  // This ensures users can only pick 5, 10, or 15 minutes (not any random number)
  duration: 5 | 10 | 15;
  
  // Array of drill types the user wants to practice
  // DrillType is defined below - this is an array of those types
  drillTypes: DrillType[];
  
  // Optional Date objects - these track when the session starts/ends
  // Date is a built-in JavaScript type for handling dates and times
  startedAt?: Date;
  completedAt?: Date;
  
  // Optional score - calculated after session completion
  // number type is for any numeric value (integers or decimals)
  score?: number;
}

/**
 * DrillType - Type Alias
 * 
 * A "type" in TypeScript can be an alias for other types.
 * Here we're creating a union type of string literals.
 * This is like an enum in Java - only these exact strings are allowed.
 * 
 * Using specific strings instead of generic 'string' type helps prevent typos
 * and makes our code more maintainable.
 */
export type DrillType = 
  | 'multiple-choice-latin-spanish'  // Show Latin, pick Spanish translation
  | 'multiple-choice-spanish-latin'  // Show Spanish, pick Latin word
  | 'fill-in-the-blank'             // Complete sentences with correct form
  | 'direct-input';                  // Type the answer directly

/**
 * DrillQuestion Interface
 * 
 * Represents a single question in a drill exercise.
 * This is what gets displayed to the user during practice.
 */
export interface DrillQuestion {
  // Unique question identifier
  id: string;
  
  // Which type of drill this question belongs to
  type: DrillType;
  
  // The word being tested - references a NormalizedLatinWord object
  word: NormalizedLatinWord;
  
  // The actual question text shown to the user
  question: string;
  
  // Optional array of multiple choice options
  // Only used for multiple-choice type questions
  options?: string[];
  
  // The correct answer to compare against
  correctAnswer: string;
  
  // What the user answered (filled in after they respond)
  userAnswer?: string;
  
  // Whether the user got it right (calculated after answering)
  isCorrect?: boolean;
}

/**
 * User Interface
 * 
 * Represents a user of the application.
 * Contains their preferences and progress statistics.
 */
export interface User {
  // Unique user identifier
  id: string;
  
  // User's display name
  name: string;
  
  // Optional email for account recovery
  email?: string;
  
  // Language code (e.g., 'es' for Spanish, 'en' for English)
  // This determines which language the UI displays in
  preferredLanguage: string;
  
  // How many consecutive days they've studied
  studyStreak: number;
  
  // Total number of unique words they've learned
  totalWordsLearned: number;
  
  // How many complete sessions they've finished
  totalSessionsCompleted: number;
}

/**
 * Additional Types for UI State Management
 * 
 * These types help manage the application's user interface state.
 * In React, "state" is data that can change over time and cause
 * the UI to re-render when it changes.
 */

/**
 * Theme Configuration
 * 
 * Defines our dark theme colors and settings
 */
export interface ThemeConfig {
  // CSS color values (hex codes like #121212 or named colors)
  primaryColor: string;      // Purple for main actions
  secondaryColor: string;    // Blue for secondary elements
  backgroundColor: string;   // Dark grey background
  surfaceColor: string;      // Slightly lighter grey for cards
  textColor: string;         // Light grey/white for text
  errorColor: string;        // Red for errors
  successColor: string;      // Green for success
}

/**
 * Screen/Route Names
 * 
 * In a Single Page Application (SPA), we don't actually change pages.
 * Instead, we swap out components to show different "screens".
 * This type defines all possible screens in our app.
 */
export type ScreenName = 
  | 'dashboard'           // Home screen
  | 'study-config'        // Configure study session
  | 'study-flashcards'    // Flashcard phase
  | 'study-drills'        // Exercise phase
  | 'vocabulary-list'     // Browse all words
  | 'settings'            // User preferences
  | 'results';            // Session results

/**
 * Vocabulary Filter Options
 * 
 * Used for filtering the vocabulary list
 */
export interface VocabularyFilter {
  // Filter by declension(s)
  declensions?: ('1st' | '2nd' | '3rd' | '4th' | '5th')[];
  
  // Filter by gender(s)
  genders?: ('masculine' | 'feminine' | 'neuter')[];
  
  // Search text for nominative or translation
  searchText?: string;
}

/**
 * Session Configuration
 * 
 * The data structure for configuring a new study session
 * This is what the user sets up before starting to study
 */
export interface SessionConfig {
  // Selected word IDs
  selectedWordIds: string[];
  
  // Session duration
  duration: 5 | 10 | 15;
  
  // Selected drill types
  selectedDrillTypes: DrillType[];
}

/**
 * API Response Types
 * 
 * When we fetch data from a server (API), we need to know what
 * format the response will be in. These types define that structure.
 * 
 * Note: Since we're not using a backend yet, these are for future use
 */

/**
 * Generic API Response wrapper
 * 
 * The <T> syntax is a "generic" - like Java generics.
 * T is a placeholder for any type we want to use.
 * This lets us reuse this interface for different data types.
 */
export interface ApiResponse<T> {
  // Was the request successful?
  success: boolean;
  
  // The actual data (type T will be specified when we use this)
  data?: T;
  
  // Error message if something went wrong
  error?: string;
  
  // HTTP status code (200 = OK, 404 = Not Found, etc.)
  statusCode: number;
}

/**
 * Example usage of the generic:
 * ApiResponse<NormalizedLatinWord[]> means the data property will be an array of NormalizedLatinWords
 * ApiResponse<User> means the data property will be a User object
 */

/**
 * Gemini API Request
 * 
 * Structure for requesting AI-generated content from Google's Gemini API
 */
export interface GeminiRequest {
  // The word we want an example sentence for
  word: NormalizedLatinWord;
  
  // What difficulty level of sentence to generate
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  
  // Optional context to make the sentence more relevant
  context?: string;
}

/**
 * Declension Helper Type
 * 
 * Maps numbers to declension strings for normalization
 */
export const DECLENSION_MAP: Record<number, string> = {
  1: '1st',
  2: '2nd',
  3: '3rd',
  4: '4th',
  5: '5th'
};